# [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

**Difficulty:** :green_circle: Easy

Given the `root` of a binary tree, return *the preorder traversal of its nodes' values*.

## Examples:

**Example 1:**

![067_01.md](./resources/067_01.jpg)

```
Input: root = [1,null,2,3]
Output: [1,2,3]

```

**Example 2:**

```
Input: root = []
Output: []

```

**Example 3:**

```
Input: root = [1]
Output: [1]

```

## Constraints:

- The number of nodes in the tree is in the range `[0, 100]`.
- `100 <= Node.val <= 100`

## Follow up:

Recursive solution is trivial, could you do it iteratively?


## Solutions

### O(n) of solution 

**Python 3**

```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        result, stack = [], [root]
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return result
```

The given solution provides an iterative approach to solve the problem using a stack.

Here is an overview of the solution:

1. Initialize an empty list called `result` to store the nodes' values during the preorder traversal.
2. If the root is None, return an empty list as there are no nodes to traverse.
3. Otherwise, initialize a stack with the root node. This stack will be used to keep track of nodes during the traversal.
4. While the stack is not empty, do the following:
   - Pop the top node from the stack and append its value to the `result` list.
   - If the popped node has a right child, push the right child onto the stack (the right child will be visited next).
   - If the popped node has a left child, push the left child onto the stack (the left child will be visited after the right child, as it is on top of the stack).
5. After the while loop finishes, return the `result` list containing the preorder traversal of the binary tree.

#### Complexity Analysis

The time complexity of this solution is O(n), where n is the number of nodes in the binary tree. In the worst case, we visit all nodes once.

The space complexity is O(h), where h is the height of the binary tree. In the worst case, the stack can contain all the nodes in one branch of the tree.

#### Summary

The given solution provides an efficient iterative approach to perform the preorder traversal of a binary tree. It uses a stack to keep track of the nodes during the traversal, and the result is stored in a list. The solution has a linear time complexity and logarithmic space complexity.

***NB***: If you want to get community points please suggest solutions in other languages as merge requests.
