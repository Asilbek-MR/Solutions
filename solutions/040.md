# [2657.Â Find the Prefix Common Array of Two Arrays](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/)

**Difficulty:** ğŸŸ¡Â Medium

You are given twoÂ **0-indexed**Â integerÂ ****permutationsÂ `A`Â andÂ `B`Â of lengthÂ `n`.

AÂ **prefix common array**Â ofÂ `A`Â andÂ `B`Â is an arrayÂ `C`Â such thatÂ `C[i]`Â is equal to the count of numbers that are present at or before the indexÂ `i`Â in bothÂ `A`Â andÂ `B`.

ReturnÂ *theÂ **prefix common array**Â of*Â `A`Â *and*Â `B`.

A sequence ofÂ `n`Â integers is called aÂ **permutation**Â if it contains all integers fromÂ `1`Â toÂ `n`Â exactly once.

## Example:

**Example 1:**

```
Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.

```

**Example 2:**

```
Input: A = [2,3,1], B = [3,1,2]
Output: [0,1,3]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: only 3 is common in A and B, so C[1] = 1.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.

```

## Constraints:

- `1 <= A.length == B.length == n <= 50`
- `1 <= A[i], B[i] <= n`
- `It is guaranteed that A and B are both a permutation of n integers.`

## Solutions

### O(n) solution

The algorithm aims to find the prefix common array between two given permutations, `A` and `B`. Here's an analysis of the algorithm's time and space complexity, considering the given constraints:

1. **Initializing Variables**: The algorithm initializes several variables: `length` to store the length of the permutations, `n` to store the maximum value in `A`, `countA` to keep track of the count of each number in `A`, `countB` to keep track of the count of each number in `B`, and `C` to store the prefix common array. The initialization of these variables takes constant time and space complexity.

2. **Counting Numbers**: The algorithm iterates over the permutations, `A` and `B`, using a range loop. For each index `i`, it increments the corresponding counts in `countA` and `countB` based on the values at `A[i]` and `B[i]`. This operation has a time complexity of O(n) according to the length of the permutations.

3. **Calculating Prefix Common Array**: The algorithm iterates over the length of the permutations and calculates the sum of the minimum counts between `countA` and `countB` for each index. It stores the result in the `C` array. This step requires a loop of length `n`, where at each iteration, it performs a zip operation and calculates the sum using a list comprehension. Both the zip operation and the list comprehension have a time complexity of O(n).

4. **Returning Result**: Finally, the algorithm returns the prefix common array `C`, which requires constant time.

Therefore, the overall time complexity of the algorithm is O(n), where n is the length of the permutations `A` and `B`.

In terms of space complexity, the algorithm utilizes additional memory for the `countA`, `countB`, and `C` arrays. The size of these arrays is determined by the maximum value in `A`, which is represented by `n`. Hence, the space complexity is O(n).

To summarize:
- Time complexity: O(n) - Linear time complexity, where n is the length of the permutations `A` and `B`.
- Space complexity: O(n) - Linear space complexity, where n is the length of the permutations `A` and `B`.

The algorithm efficiently calculates the prefix common array by counting the occurrences of numbers in the given permutations and then calculating the minimum counts for each index. The algorithm's performance is within the given constraints, ensuring efficient computation for permutations of moderate length.

```python3
class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        length, n = len(A), max(A)
        countA, countB, C = [0] * (n+1), [0] * (n+1), [0] * length
        for i in range(length):
            countA[A[i]] += 1
            countB[B[i]] += 1
            C[i] = sum([min(count_a, count_b) for count_a, count_b in zip(countA, countB)])
        return C
```

***NB***: If you want to get community points please suggest solutions in other languages as merge requests.
