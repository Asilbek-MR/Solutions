# [2130. Maximum Twin Sum of a Linked List](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/)

**Difficulty:** :green_circle: Easy| :yellow_circle: Medium| :red_circle: Hard

In a linked list of size `n`, where `n` is **even**, the `ith` node (**0-indexed**) of the linked list is known as the **twin** of the `(n-1-i)th` node, if `0 <= i <= (n / 2) - 1`.

- For example, if `n = 4`, then node `0` is the twin of node `3`, and node `1` is the twin of node `2`. These are the only nodes with twins for `n = 4`.

The **twin sum** is defined as the sum of a node and its twin.

Given the `head` of a linked list with even length, return *the **maximum twin sum** of the linked list*.

## Examples:

**Example 1:**

![https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png](https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png)

```
Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6.

```

**Example 2:**

![https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png](https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png)

```
Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7.

```

**Example 3:**

![https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png](https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png)

```
Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.

```

## Constraints:

- The number of nodes in the list is an **even** integer in the range `[2, 105]`.
- `1 <= Node.val <= 105`

## Solutions

### O(n) solution 

```python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def _get_middle(self, head: Optional[ListNode]):
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow

    def _reverse(self, head: Optional[ListNode], middle: Optional[ListNode]) -> Optional[ListNode]:
        new_head = head
        head = head.next
        new_head.next = None

        while head != middle:
            node = head
            head = head.next
            node.next = new_head
            new_head = node
        return new_head

    def pairSum(self, head: Optional[ListNode]) -> int:
        middle = self._get_middle(head)
        reversed_head = self._reverse(head, middle)
        maximum = 0
        while middle and reversed_head:
            maximum = max(maximum, middle.val+reversed_head.val)
            middle = middle.next 
            reversed_head = reversed_head.next
        return maximum
```

The given solution uses a two-step process to find the maximum twin sum in the linked list.

Step 1: Find the Middle Node
1. Define a helper function `_get_middle` that takes the head of the linked list as input.
2. Initialize two pointers, `slow` and `fast`, both pointing to the head of the linked list.
3. Iterate over the linked list with a condition that `fast` and `fast.next` are not `None`.
   - In each iteration, move `slow` one step ahead (`slow = slow.next`) and `fast` two steps ahead (`fast = fast.next.next`).
4. Return the node pointed to by `slow`. This will be the middle node of the linked list.

Step 2: Find the Maximum Twin Sum
1. Define a helper function `_reverse` that takes the head of the linked list and the middle node as inputs.
2. Initialize a new head pointer, `new_head`, pointing to the original head of the linked list.
3. Move the original head one step ahead (`head = head.next`) and set `new_head.next` to `None`.
4. Iterate over the remaining nodes of the linked list until reaching the middle node.
   - In each iteration, perform the following steps:
     - Store the current `head` node in a temporary variable (`node = head`).
     - Move `head` one step ahead (`head = head.next`).
     - Set the `next` pointer of the `node` to the current `new_head` (`node.next = new_head`).
     - Update `new_head` to point to the `node` (`new_head = node`).
5. Return `new_head`. This will be the reversed portion of the linked list from the original head to the middle node.

3. In the `pairSum` function, call the `_get_middle` function to get the middle node of the linked list.
4. Call the `_reverse` function to reverse the first half of the linked list from the head to the middle node.
5. Initialize a variable `maximum` to store the maximum twin sum and set it to `0`.
6. Iterate over the middle node and the reversed portion of the linked list simultaneously.
   - In each iteration, calculate the twin sum of the current nodes (`middle.val + reversed_head.val`) and update `maximum` if necessary.
   - Move both pointers to their next nodes (`middle = middle.next` and `reversed_head = reversed_head.next`).
7. Return `maximum`, which represents the maximum twin sum in the linked list.

#### Complexity Analysis

The time complexity of the algorithm is O(n) because we traverse the linked list once to find the middle node and then iterate over the middle node and the reversed portion of the linked list.

The space complexity of the algorithm is O(1) because it uses a constant amount of additional space to store the pointers and variables.

#### Summary

The given solution finds the maximum twin sum in a linked list using a two-step process. First, it finds the middle node of the linked list using the two-pointer technique. Then, it reverses the first half of the linked list up to the middle node. Finally, it iterates over the middle node and the reversed portion of the linked list, calculating the twin sum and updating the maximum value. The algorithm has a time complexity of O(n) and a space complexity of O(1).

***NB***: If you want to get community points please suggest solutions in other languages as merge requests.
